{"file":"/home/heroku/Projects/Studying/NestJS/nestjs-task-managemenet/backend/src/auth/user.repository.ts","mappings":";;;;;;;;AAAA,qCAAsD;AACtD,2CAAgF;AAChF,mCAAkC;AAClC,+CAAoC;AAIpC,IAAa,cAAc,GAA3B,MAAa,cAAe,SAAQ,oBAAgB;IACnD,KAAK,CAAC,MAAM,CAAC,kBAAsC;QAClD,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,kBAAkB,CAAA;QAEjD,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,EAAE,CAAA;QAC1B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACxB,IAAI,CAAC,IAAI,GAAG,MAAM,MAAM,CAAC,OAAO,EAAE,CAAA;QAClC,IAAI,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;QAE5D,IAAI;YACH,MAAM,IAAI,CAAC,IAAI,EAAE,CAAA;SACjB;QAAC,OAAO,CAAC,EAAE;YACX,IAAI,CAAC,CAAC,IAAI,KAAK,OAAO,EAAE;gBACvB,oBAAoB;gBACpB,MAAM,IAAI,0BAAiB,CAAC,yBAAyB,CAAC,CAAA;aACtD;iBAAM;gBACN,MAAM,IAAI,qCAA4B,EAAE,CAAA;aACxC;SACD;IACF,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,kBAAsC;QAChE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,kBAAkB,CAAA;QACjD,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAA;QAE7C,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,EAAE;YACpD,OAAO,IAAI,CAAC,QAAQ,CAAA;SACpB;aAAM;YACN,OAAO,IAAI,CAAA;SACX;IACF,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,QAAgB,EAAE,IAAY;QACxD,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAA;IACnC,CAAC;CACD,CAAA;AAnCY,cAAc;IAD1B,0BAAgB,CAAC,kBAAI,CAAC;GACV,cAAc,CAmC1B;AAnCY,wCAAc","names":[],"sources":["/home/heroku/Projects/Studying/NestJS/nestjs-task-managemenet/backend/src/auth/user.repository.ts"],"sourcesContent":["import { EntityRepository, Repository } from 'typeorm'\nimport { ConflictException, InternalServerErrorException } from '@nestjs/common'\nimport * as bcrypt from 'bcryptjs'\nimport { User } from './user.entity'\nimport { AuthCredentialsDto } from './dto/auth-credentials.dto'\n\n@EntityRepository(User)\nexport class UserRepository extends Repository<User> {\n\tasync signUp(authCredentialsDto: AuthCredentialsDto): Promise<void> {\n\t\tconst { username, password } = authCredentialsDto\n\n\t\tconst user = this.create()\n\t\tuser.username = username\n\t\tuser.salt = await bcrypt.genSalt()\n\t\tuser.password = await this.hashPassword(password, user.salt)\n\n\t\ttry {\n\t\t\tawait user.save()\n\t\t} catch (e) {\n\t\t\tif (e.code === '23505') {\n\t\t\t\t//dublicate username\n\t\t\t\tthrow new ConflictException('Username already exists')\n\t\t\t} else {\n\t\t\t\tthrow new InternalServerErrorException()\n\t\t\t}\n\t\t}\n\t}\n\n\tasync validateUserPassword(authCredentialsDto: AuthCredentialsDto): Promise<string> {\n\t\tconst { username, password } = authCredentialsDto\n\t\tconst user = await this.findOne({ username })\n\n\t\tif (user && (await user.validatePassword(password))) {\n\t\t\treturn user.username\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tprivate async hashPassword(password: string, salt: string): Promise<string> {\n\t\treturn bcrypt.hash(password, salt)\n\t}\n}\n"],"version":3}